**Summary**: This PR introduces a new error handling system with structured logging, replacing the basic error handling in `error_handler.py`. 
The changes improve error handling and logging, but some issues need to be addressed before merge.

**Critical Bugs**:
1. The file is missing a newline at the end, which can cause issues with some tools. **Add a newline at the end of the file**.
2. In `complex_operation`, the `ValidationError` for "data_type" should be raised with a more descriptive message, e.g., "Data must be of type int, float, list, or dict".

**Important Improvements**:
1. Consider adding a `logging.config` to configure logging levels and formats for different environments.
2. In `process_data`, the `AppError` raised in the `except Exception` block should include more context, e.g., the original exception message.

**Code Quality & Maintainability**:
1. The `complex_operation` function is doing too much; consider breaking it down into separate functions for each data type.
2. The `process_data` function can be simplified by removing the redundant `logger.info` calls and using a more descriptive variable name instead of `data`.

**Tests & CI**:
1. There are no tests for the new error handling system; **add unit tests to cover different error scenarios**.
2. Consider adding integration tests to verify the logging configuration and error handling in a real-world scenario.

**Positive notes**:
1. The introduction of structured logging with `logging` and `extra` context is a significant improvement.
2. The use of custom exception classes (`AppError` and `ValidationError`) provides better error handling and context. 

Example of improved `complex_operation` function:
```python
def validate_data(data: Any) -> None:
    """Validate data type and value"""
    if not data:
        raise ValidationError("Data cannot be empty")
    if not isinstance(data, (int, float, list, dict)):
        raise ValidationError("Data must be of type int, float, list, or dict", "data_type")

def process_int_float(data: int | float) -> int | float:
    """Process int or float data"""
    return data * 2

def process_list(data: list) -> list:
    """Process list data"""
    return [item * 2 for item in data]

def process_dict(data: dict) -> dict:
    """Process dict data"""
    return {k: v * 2 for k, v in data.items()}

def complex_operation(data: Any) -> Any:
    """Complex operation with proper validation"""
    validate_data(data)
    if isinstance(data, (int, float)):
        return process_int_float(data)
    elif isinstance(data, list):
        return process_list(data)
    else:  # dict
        return process_dict(data)
```